import os

out_str = "// !!! This file is autogenerated! Do not edit !!!\n\n#include <stdint.h>\n#include <stddef.h>\n\n"
input_dir = "../../engine/resources/"
identifier_start = "engine://"
to_load = []

def sanitize_path(path):
    return path.replace("/", "_").replace("\"", "_").replace(".", "_").replace("'", "_").replace("?", "_").replace(".", "_").replace("(", "_").replace(")", "_").replace("[", "_").replace("]", "_").replace("{", "_").replace("}", "_")

def embed_resource(path):
    global out_str
    identifier = f"{identifier_start}{path.replace(input_dir, '')}"
    
    f = open(path, "rb")

    f_size = os.path.getsize(path)
    out_str += f"static const uint8_t g_{sanitize_path(path)}[{f_size}] = {{\n" 

    chunk = f.read(16)
    while chunk:
        out_str += "    "
        for c in chunk:
            out_str += '0x{:<02X},'.format(c)
        out_str += "\n"
        chunk = f.read(16)

    out_str += "};"
    out_str += "\n"

    to_load.append([identifier, f"g_{sanitize_path(path)}", f_size])

for [relative_path, dir, files] in os.walk(input_dir, "**"):
    if files != []:
        for file in files:
            embed_resource(os.path.join(relative_path, file).replace("\\", "/"))

# Generate load function
out_str += "\nvoid engine_load_embedded_resource(const char* szId, const uint8_t* pData, size_t sSize);\n"
out_str += "\nvoid init_embedded_resources() {\n"

for [i, g, s] in to_load:
    out_str += f'    engine_load_embedded_resource("{i}", {g}, {s});\n'

out_str += "}\n"

f = open("embedded_resources.cc", "w")
f.write(out_str)
f.close()
